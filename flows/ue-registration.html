<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>5GC 信令流程图 - 可调布局 (支持缩放/平移)</title>
  <style>
    /* ===== 基础布局 ===== */
    html,body{margin:0;padding:0;height:100%;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;}
    #container{display:flex;height:100vh;overflow:hidden;}

    /* ===== 左侧信令图容器 =====
       修复：去掉原先的 cursor:grab; 以免在左侧空白区域出现“小手掌”指针 */
    #diagram-container{flex:1;position:relative;overflow:hidden;}

    #header-names{position:absolute;top:0;left:0;right:0;height:50px;background:#fff;border-bottom:1px solid #eee;overflow:hidden;pointer-events:none;}
    #header-names-inner{position:absolute;top:0;left:0;height:100%;}
    #header-names-inner .node-name{position:absolute;top:50%;transform:translate(-50%,-50%);font-size:14px;color:#333;}
    #diagram-body{position:absolute;top:50px;bottom:0;left:0;right:0;overflow:auto;}
    #diagram{display:block;}

    /* ===== 垂直分隔条 ===== */
    #vertical-divider{width:5px;background:#ddd;cursor:col-resize;user-select:none;}

    /* ===== 右侧面板 ===== */
    #viewer-wrapper{width:400px;display:flex;flex-direction:column;overflow:hidden;}
    #viewer-header{flex:none;padding:10px 12px;background:#f5f5f5;border-bottom:1px solid #ccc;font-weight:bold;}

    /* ===== 右侧上下分区父容器 ===== */
    #right-detail{position:relative;flex:1;min-height:0;}

    /* ===== 右侧上下内容区 ===== */
    #json-viewer {
      position:absolute;left:0;right:0;
      padding:10px;font-size:14px;line-height:1.4;
      overflow-y:auto;box-sizing:border-box;
    }
    #comment-viewer {
      position:absolute;left:0;right:0;
      padding:10px;font-size:14px;line-height:1.4;
      overflow-y:auto;box-sizing:border-box;
    }
    #json-viewer details{margin-left:12px;margin-bottom:4px;}
    #json-viewer summary{cursor:pointer;}

    /* ===== 水平分隔条 ===== */
    #horizontal-divider{
      position:absolute;left:0;right:0;height:5px;background:#ddd;
      cursor:row-resize;user-select:none;
    }

    /* ===== 信令文字标签 ===== */
    .message-label{cursor:default;}
    .message-label:hover{fill:#007ACC;}

    #comment-content {
      max-width: 800px;
      margin: 0 auto;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    #comment-content code {
      font-family: Consolas,"Courier New",monospace;
      background-color: #f5f5f5;
      padding: 2px 4px;
      border-radius: 3px;
    }
    #comment-content pre code {
      background-color: transparent;
      padding: 0;
    }
    #comment-content pre {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 3px;
      overflow-x: auto;
    }
    #comment-content ul, #comment-content ol {
      margin: 0.5em 0;
      padding-left: 1.5em;
    }
    #comment-content li {
      margin: 0.2em 0;
    }
    #comment-viewer::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    #comment-viewer::-webkit-scrollbar-thumb {
      background-color: rgba(0,0,0,0.3);
      border-radius: 4px;
    }
    #comment-viewer::-webkit-scrollbar-track {
      background-color: #f5f5f5;
    }
  </style>

  <style id="addon-style">
    .message-label.selected{fill:#ff5722;font-weight:bold;}
  </style>
</head>
<body>
  <div id="container">
    <!-- 左侧信令图 -->
    <div id="diagram-container">
      <div id="header-names"><div id="header-names-inner"></div></div>
      <div id="diagram-body"><svg id="diagram"></svg></div>
    </div>

    <!-- 垂直分隔条 -->
    <div id="vertical-divider"></div>

    <!-- 右侧消息详情 -->
    <div id="viewer-wrapper">
      <div id="viewer-header">消息详情</div>
      <div id="right-detail">
        <div id="json-viewer">请点击左侧消息查看详情</div>
        <div id="horizontal-divider"></div>
        <div id="comment-viewer">
           <div id="comment-content">请点击左侧消息查看注释</div>
         </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/16.1.1/lib/marked.umd.min.js"></script>
  <script>
      document.addEventListener('DOMContentLoaded', () => {
      /* ====== 数据 ====== */
      const nodes=["UE","gNB","AMF","NRF","AUSF","UDM","UDR","NSSF","PCF","SMF","UPF","SMSF","EIR"];
      const messages = [
          {from: "UE", to: "gNB", label: "1  RRCConnectionRequest", info: {
              header: {msg: "RRCConnectionRequest", protocol: "RRC"},
              payload: {
                  "ueIdentity [Mandatory]": {randomValue: "0xABCDEF"},
                  "establishmentCause [Mandatory]": "mo-Signalling"
              }
          }, comment: "UE initiates RRC connection establishment by sending an RRC Connection Request with a random UE identity (for contention resolution) and cause mo-Signalling. \n- **ueIdentity** [Mandatory]: Initial UE identity used for this connection. It can be an S-TMSI (if the UE has a valid previous ID) or a random value. Here the UE sends a random value since it’s the first attach or no valid S-TMSI is available:contentReference[oaicite:0]{index=0}.\n- **establishmentCause** [Mandatory]: Indicates the reason for establishing the RRC connection. “mo-Signalling” means the UE initiated the connection for mobile-originated signalling (i.e. to send NAS signaling for registration):contentReference[oaicite:1]{index=1}."
          },
          {from: "gNB", to: "UE", label: "2  RRCSetup", info: {
              header: {msg: "RRCSetup", protocol: "RRC"},
              payload: {
                  "rrcTransactionIdentifier [Mandatory]": 0,
                  "radioBearerConfig [Mandatory]": {
                      "srb_ToAddModList [Optional]": [
                          {"srb_Identity [Mandatory]": 1}
                      ]
                  },
                  "masterCellGroup [Mandatory]": {
                      "cellGroupId [Mandatory]": 0,
                      "rlc_BearerToAddModList [Optional]": [],
                      "mac_CellGroupConfig [Optional]": {},
                      "physicalCellGroupConfig [Optional]": {}
                  }
              }
          }, comment: "gNB responds with RRC Setup, configuring SRB1 for signaling and initial radio parameters (Master Cell Group configuration). \n- **rrcTransactionIdentifier** [Mandatory]: Identifier for this RRC transaction (0 for the initial transaction).\n- **radioBearerConfig** [Mandatory]: Configuration of radio bearers dedicated to this connection (corresponds to the radioResourceConfigDedicated in RRC Setup). This includes the setup of SRB1 for signaling:contentReference[oaicite:2]{index=2}.\n  - **srb_ToAddModList** [Optional]: List of Signaling Radio Bearers to add or modify. Present here to set up SRB1 (the primary signaling bearer):contentReference[oaicite:3]{index=3}.\n    - **srb_Identity** [Mandatory]: The identifier of the SRB being configured (value 1 for SRB1).\n- **masterCellGroup** [Mandatory]: Configuration of the Master Cell Group (the primary cell group for NR). Contains MAC and PHY layer settings for the UE’s connection.\n  - **cellGroupId** [Mandatory]: Identifier of the cell group (0 for the primary cell group).\n  - **rlc_BearerToAddModList** [Optional]: List of RLC bearers to add or modify. Omitted or empty if no additional RLC bearers are configured (empty here, as no DRB is configured in RRC Setup).\n  - **mac_CellGroupConfig** [Optional]: MAC layer configuration for the cell group. An empty object here indicates default or no special MAC configuration is provided (using spec defaults).\n  - **physicalCellGroupConfig** [Optional]: Physical layer configuration for the cell group. An empty object means default PHY configuration is assumed."
          },
          {from: "UE", to: "gNB", label: "3  RRCSetupComplete", info: {
              header: {msg: "RRCSetupComplete", protocol: "RRC"},
              payload: {
                  "rrcTransactionIdentifier [Mandatory]": 0,
                  "selectedPLMN_Identity [Mandatory]": "001/01",
                  "dedicatedNAS_Message [Optional]": {
                      "messageType": "RegistrationRequest",
                      "registrationType": "Initial Registration",
                      "nasKeySetIdentifier": {tsc: "native", value: 0},
                      "fiveGMMCapability": "0xE0",
                      "ueSecurityCapability": {
                          nrEncryptionAlgorithms: ["NEA0", "NEA1", "NEA2"],
                          nrIntegrityAlgorithms: ["NIA1", "NIA2", "NIA3"],
                          eutraEncryptionAlgorithms: ["EEA0", "EEA1", "EEA2"],
                          eutraIntegrityAlgorithms: ["EIA1", "EIA2"]
                      },
                      "fiveGSMobileIdentity": {
                          type: "5G-GUTI",
                          plmnId: "001/01",
                          amfRegionId: 1,
                          amfSetId: 1,
                          amfPointer: 1,
                          tmsi: "0xABCDEF12"
                      },
                      "requestedNSSAI": [{sst: 1, sd: "010203"}]
                  }
              }
          }, comment: "UE confirms RRC setup and includes the NAS Registration Request (with initial registration type, old GUTI, capabilities, etc.). \n- **rrcTransactionIdentifier** [Mandatory]: Echoes the transaction identifier from the RRC Setup (0), indicating this message completes that transaction.\n- **selectedPLMN_Identity** [Mandatory]: Index of the PLMN that the UE has selected from the broadcast list (here ‘1’ corresponds to PLMN 001/01). This field is used when multiple PLMNs are available in the cell:contentReference[oaicite:4]{index=4}.\n- **dedicatedNAS_Message** [Optional]: Contains a NAS message to be delivered to the core network. Here it carries the UE’s **Registration Request** for 5G NAS.\n  - **messageType** [Mandatory]: *Registration Request* – the NAS message by which the UE requests to register with the network.\n  - **registrationType** [Mandatory]: Indicates the type of registration. *Initial Registration* is used for the first attach or when no valid 5G core context exists:contentReference[oaicite:5]{index=5}.\n  - **nasKeySetIdentifier** [Mandatory]: An identifier for the UE’s NAS security context. It includes a *Type of Security Context* (TSC, here “native”) and a key set identifier value (here 0) to indicate the currently used NAS key set:contentReference[oaicite:6]{index=6}.\n  - **fiveGMMCapability** [Optional]: The UE’s 5G MM capability information (0xE0). This IE contains capability bits (e.g. for periodic DRX, Positioning, etc.) and is included only if the UE has relevant features to announce:contentReference[oaicite:7]{index=7}.\n  - **ueSecurityCapability** [Mandatory]: The set of security algorithms supported by the UE for NAS signaling and ciphering. It lists supported NR encryption (NEA) and integrity (NIA) algorithms, and also E-UTRA algorithms for interworking. This allows the network to choose mutually supported algorithms:contentReference[oaicite:8]{index=8}.\n  - **fiveGSMobileIdentity** [Mandatory]: The UE’s identity for 5G core network registration. Here it is a *5G-GUTI* (Globally Unique Temporary Identifier) from a previous registration, which includes the PLMN ID and AMF identifiers and the UE’s TMSI. Providing the old GUTI allows the network to retrieve the UE’s context if it exists:contentReference[oaicite:9]{index=9}.\n  - **requestedNSSAI** [Optional]: The Network Slice Selection Assistance Information the UE requests. This is the list of slice identifiers (S-NSSAIs) the UE wants service from. Here the UE requests slice with SST 1 and SD “010203”:contentReference[oaicite:10]{index=10}."
          },
          {from: "gNB", to: "AMF", label: "4  InitialUEMessage", info: {
              header: {msg: "InitialUEMessage", protocol: "NGAP"},
              payload: {
                  "ranUeNgapId [Mandatory]": 1,
                  "nasPdu [Mandatory]": {
                      "messageType": "RegistrationRequest",
                      "registrationType": "Initial Registration",
                      "nasKeySetIdentifier": {tsc: "native", value: 0},
                      "fiveGMMCapability": "0xE0",
                      "ueSecurityCapability": {
                          nrEncryptionAlgorithms: ["NEA0", "NEA1", "NEA2"],
                          nrIntegrityAlgorithms: ["NIA1", "NIA2", "NIA3"],
                          eutraEncryptionAlgorithms: ["EEA0", "EEA1", "EEA2"],
                          eutraIntegrityAlgorithms: ["EIA1", "EIA2"]
                      },
                      "fiveGSMobileIdentity": {
                          type: "5G-GUTI",
                          plmnId: "001/01",
                          amfRegionId: 1,
                          amfSetId: 1,
                          amfPointer: 1,
                          tmsi: "0xABCDEF12"
                      },
                      "requestedNSSAI": [{sst: 1, sd: "010203"}]
                  },
                  "userLocationInformation [Mandatory]": {
                      tai: {plmnId: "001/01", tac: "000A"}
                  },
                  "ueContextRequest [Optional]": "requested",
                  "rrcEstablishmentCause [Mandatory]": "mo-Signalling",
                  "fivegSTmsi [Optional]": "0xABCDEF12",
                  "amfSetId [Optional]": 1
              }
          }, comment: "gNB forwards the UE's Registration Request to the AMF in an Initial UE Message, including the RAN UE NGAP ID, user location (TAI), the 5G-S-TMSI from the GUTI, and indicating that a UE context is requested. \n- **ranUeNgapId** [Mandatory]: The UE’s RAN-assigned ID for NGAP (gNB UE NGAP ID). This identifier (1) was allocated by the gNB to represent the UE over the NG interface, and the AMF will use it to refer to the UE’s context:contentReference[oaicite:11]{index=11}.\n- **nasPdu** [Mandatory]: The NAS PDU carried transparently to the AMF – here the Registration Request message from the UE.\n  - **messageType** [Mandatory]: *Registration Request* – same NAS message type as described above.\n  - **registrationType** [Mandatory]: *Initial Registration*, indicating a full attach to the 5G core:contentReference[oaicite:12]{index=12}.\n  - **nasKeySetIdentifier** [Mandatory]: NAS security context identifier (TSC “native”, value 0) as provided by the UE:contentReference[oaicite:13]{index=13}.\n  - **fiveGMMCapability** [Optional]: UE’s 5G mobility management capability information (0xE0), provided only if the UE has additional capabilities to convey:contentReference[oaicite:14]{index=14}.\n  - **ueSecurityCapability** [Mandatory]: UE-supported NAS encryption and integrity algorithms (same values as in RRC Setup Complete):contentReference[oaicite:15]{index=15}.\n  - **fiveGSMobileIdentity** [Mandatory]: UE’s identity for registration, here the old 5G-GUTI (with PLMN 001/01 and AMF IDs) to help the AMF retrieve any stored context:contentReference[oaicite:16]{index=16}.\n  - **requestedNSSAI** [Optional]: UE’s requested network slice(s) (SST 1, SD 010203) for service:contentReference[oaicite:17]{index=17}.\n- **userLocationInformation** [Mandatory]: The UE’s location info, specifically the Tracking Area Identity (TAI). Here it indicates PLMN 001/01 and TAC 0x000A, identifying the cell’s tracking area:contentReference[oaicite:18]{index=18}.\n- **ueContextRequest** [Optional]: Indicates that the gNB requests the AMF to set up a UE context (i.e., the gNB is asking the AMF to initiate Initial Context Setup for this UE):contentReference[oaicite:19]{index=19}.\n- **rrcEstablishmentCause** [Mandatory]: The cause for RRC connection establishment as passed to the AMF. “mo-Signalling” informs the AMF that the UE’s RRC connection was initiated for signaling purposes (registration):contentReference[oaicite:20]{index=20}.\n- **fivegSTmsi** [Optional]: The 5G-S-TMSI (short form of the UE’s GUTI) as provided by the UE. If the UE’s Registration Request included a GUTI, the gNB extracts the 5G-S-TMSI and includes it so the AMF can recognize the UE (e.g., for context retrieval):contentReference[oaicite:21]{index=21}.\n- **amfSetId** [Optional]: The AMF Set Identifier associated with the UE’s GUTI. This helps route the message to the correct AMF pool or indicate if the message might be for a different AMF set. (Included if a GUTI was present; if this IE is present, the AMF knows the message could be rerouted based on 5G-GUTI):contentReference[oaicite:22]{index=22}."
          },
          {from: "AMF", to: "gNB", label: "5  DownlinkNASTransport (IdentityRequest)", info: {
              header: {msg: "DownlinkNASTransport", protocol: "NGAP"},
              payload: {
                  "nasPdu [Mandatory]": {
                      messageType: "IdentityRequest",
                      identityType: "SUCI"
                  }
              }
          }, comment: "AMF initiates the identity procedure, asking the UE to provide its SUCI (Subscription Concealed Identifier). \n- **nasPdu** [Mandatory]: Contains the NAS *Identity Request* message sent by the AMF.\n  - **messageType** [Mandatory]: *Identity Request*, indicating a NAS request for the UE’s identity.\n  - **identityType** [Mandatory]: Specifies which identity is requested. Here it is *SUCI*, meaning the AMF is asking for the UE’s Subscription Concealed Identifier (the protected form of the SUPI)."
          },
          {from: "gNB", to: "UE", label: "6  DLInformationTransfer (IdentityRequest)", info: {
              header: {msg: "DLInformationTransfer", protocol: "RRC"},
              payload: {
                  "dedicatedNAS_Message [Optional]": {
                      messageType: "IdentityRequest",
                      identityType: "SUCI"
                  }
              }
          }, comment: "gNB delivers the Identity Request NAS message to the UE. \n- **dedicatedNAS_Message** [Optional]: The NAS Identity Request conveyed in an RRC message to the UE.\n  - **messageType** [Mandatory]: *Identity Request* (NAS message as above).\n  - **identityType** [Mandatory]: *SUCI*, indicating the UE should respond with its SUCI (encrypted subscriber identity)."
          },
          {from: "UE", to: "gNB", label: "7  ULInformationTransfer (IdentityResponse)", info: {
              header: {msg: "ULInformationTransfer", protocol: "RRC"},
              payload: {
                  "dedicatedNAS_Message [Optional]": {
                      messageType: "IdentityResponse",
                      fiveGSMobileIdentity: {type: "SUCI", value: "suci-0-001-01-XXXXXXXXXXXXXXXX"}
                  }
              }
          }, comment: "UE responds with an Identity Response containing its SUCI (encrypted SUPI). \n- **dedicatedNAS_Message** [Optional]: The NAS *Identity Response* sent by the UE, carried via RRC.\n  - **messageType** [Mandatory]: *Identity Response*.\n  - **fiveGSMobileIdentity** [Mandatory]: The identity data provided by the UE. Here it is of type *SUCI*, including the SUCI string (concealed SUPI). The SUCI is the UE’s subscriber identity encrypted with the home network’s public key, so that the UE’s IMSI is not sent in cleartext:contentReference[oaicite:23]{index=23}."
          },
          {from: "gNB", to: "AMF", label: "8  UplinkNASTransport (IdentityResponse)", info: {
              header: {msg: "UplinkNASTransport", protocol: "NGAP"},
              payload: {
                  "nasPdu [Mandatory]": {
                      messageType: "IdentityResponse",
                      fiveGSMobileIdentity: {type: "SUCI", value: "suci-0-001-01-XXXXXXXXXXXXXXXX"}
                  }
              }
          }, comment: "gNB forwards the Identity Response (with SUCI) to the AMF. \n- **nasPdu** [Mandatory]: Contains the NAS *Identity Response* message from the UE.\n  - **messageType** [Mandatory]: *Identity Response*.\n  - **fiveGSMobileIdentity** [Mandatory]: The identity provided by the UE – in this case, the SUCI (encrypted SUPI), which the AMF will use to derive the actual subscriber identity."
          },
          {from: "AMF", to: "NRF", label: "9  Nnrf_NFDiscovery (AUSF)", info: {
              http: {method: "GET", uri: "/nnrf-nfm/v1/nf-instances?targetNfType=AUSF&requesterNfType=AMF&serviceNames=nausf-auth"}
          }, comment: "AMF uses NRF to discover a suitable AUSF for authentication. \n- **method**: GET (NF discovery query).\n- **uri**: Contains query parameters for NF discovery – **targetNfType=AUSF** (the AMF is looking for an AUSF NF instance) and **requesterNfType=AMF** (identifying itself for filtering). The AMF also specifies **serviceNames=nausf-auth** to find an AUSF that provides the authentication service."
          },
          {from: "NRF", to: "AMF", label: "10  Nnrf_NFDiscovery Response", info: {
              status: 200,
              body: {
                  nfInstances: [{
                      nfType: "AUSF",
                      nfInstanceId: "ausf1",
                      endpoint: "https://ausf.example.com/nausf-auth/v1"
                  }]
              }
          }, comment: "NRF returns the AUSF's NF profile (API endpoint) to the AMF. \n- **nfInstances** [Mandatory]: List of NF instances matching the query. Here a single AUSF instance is returned.\n  - **nfType** [Mandatory]: Type of the NF (AUSF).\n  - **nfInstanceId** [Mandatory]: Identifier of the discovered AUSF instance (e.g., “ausf1”).\n  - **endpoint** [Mandatory]: The base URL of the AUSF’s service API (for the UE authentication service)."
          },
          {from: "AMF", to: "AUSF", label: "11  Nausf_UEAuthentication Request", info: {
              http: {method: "POST", uri: "/nausf-auth/v1/ue-authentications"},
              body: {suci: "suci-0-001-01-...", servingNetworkName: "5G:mnc001.mcc001.3gppnetwork.org"}
          }, comment: "AMF requests UE authentication vectors and algorithm information from the AUSF. \n- **method**: POST (initiates an authentication procedure at the AUSF).\n- **uri**: */ue-authentications* endpoint of the AUSF’s service.\n- **body**: \n  - **suci** [Mandatory]: The UE’s Subscription Concealed Identifier (the UE’s encrypted SUPI) that will be used for generating authentication vectors.\n  - **servingNetworkName** [Mandatory]: The identifier of the serving network (PLMN) – here `5G:mnc001.mcc001.3gppnetwork.org` – used by the AUSF/UDM to derive authentication data specific to that network."
          },
          {from: "AUSF", to: "UDM", label: "12  Nudm_Authentication_Get Request", info: {
              http: {method: "POST", uri: "/nudm-ueau/v1/{supi}/security-information/generate-auth-data"},
              body: {supi: "imsi-001010000000001", authType: "5G-AKA"}
          }, comment: "AUSF requests an authentication vector from the UDM. \n- **supi** [Mandatory]: The subscriber’s permanent identity (IMSI) for which authentication data is being requested. (The AUSF has derived this from the SUCI.)\n- **authType** [Mandatory]: The authentication method to use – here *5G-AKA*, indicating that 5G AKA authentication vectors are needed."
          },
          {from: "UDM", to: "UDR", label: "13  Nudr_DM_Query (AuthData)", info: {
              http: {method: "POST", uri: "/nudr-dr/v1/subscription-data/{supi}/authentication-data"},
              body: {supi: "imsi-001010000000001", servingNetworkName: "001-01"}
          }, comment: "UDM retrieves the subscriber's authentication data from the UDR. \n- **supi** [Mandatory]: The subscriber’s unique ID (IMSI) for which auth data is requested.\n- **servingNetworkName** [Mandatory]: The serving network’s identifier (MCC/MNC in this query – 001/01) to fetch network-specific authentication info."
          },
          {from: "UDR", to: "UDM", label: "14  Nudr_DM_Query Response", info: {
              status: 200,
              body: {authenticationVector: {rand: "0x1234567890ABCDEF...", hxresStar: "HXRES*", autn: "AUTN", k: "K"}}
          }, comment: "UDR returns the authentication vector (RAND, XRES*, AUTN, K etc) to the UDM. \n- **authenticationVector** [Mandatory]: The components of the authentication vector retrieved for the subscriber:\n  - **rand** [Mandatory]: A 128-bit Random challenge generated for 5G-AKA.\n  - **hxresStar** [Mandatory]: The hashed expected response (XRES*) for the challenge (used by the AUSF to verify the UE’s response).\n  - **autn** [Mandatory]: The authentication token for the UE (allows the UE to verify the network and derive response).\n  - **k** [Mandatory]: The subscriber’s master key (K) or key material needed for deriving session keys. (This is the secret from the UDR used by the UDM’s auth function to compute K_SEAF and XRES*.)"
          },
          {from: "UDM", to: "AUSF", label: "15  Nudm_Authentication_Get Response", info: {
              status: 200,
              body: {authVector: {rand: "0x1234567890ABCDEF...", autn: "AUTN", xresStar: "XRES*", kseaf: "K_SEAF"}}
          }, comment: "UDM returns the authentication vector to the AUSF. \n- **authVector** [Mandatory]: The authentication data for the UE:\n  - **rand**: Random challenge (same RAND as sent in the request).\n  - **autn**: Authentication token for the UE.\n  - **xresStar**: The expected response XRES* (unhashed) for the challenge, to be used by AUSF for verification.\n  - **kseaf**: The key K_SEAF derived from the master key, which will be used as the anchor key for deriving session keys between UE and AMF."
          },
          {from: "AUSF", to: "AMF", label: "16  Nausf_UEAuthentication Response", info: {
              status: 200,
              body: {rand: "0x1234567890ABCDEF...", autn: "AUTN", hxresStar: "HXRES*", kseaf: "K_SEAF"}
          }, comment: "Once the UE is authenticated, AUSF provides the challenge (RAND, AUTN) and key material (HXRES*, K_SEAF) to the AMF. \n- **rand** [Mandatory]: The random challenge that was sent to the UE.\n- **autn** [Mandatory]: The authentication token for the UE corresponding to that RAND.\n- **hxresStar** [Mandatory]: The hashed expected response that the AUSF will use to compare with the UE’s actual response (RES*).\n- **kseaf** [Mandatory]: The anchor key (K_SEAF) derived for this UE, which the AMF will use to derive further keys (e.g., K_AMF) for NAS security."
          },
          {from: "AMF", to: "gNB", label: "17  DownlinkNASTransport (AuthenticationRequest)", info: {
              header: {msg: "DownlinkNASTransport", protocol: "NGAP"},
              payload: {
                  "nasPdu [Mandatory]": {
                      messageType: "AuthenticationRequest",
                      rand: "0x1234567890ABCDEF1234567890ABCDEF",
                      autn: "0xABCDEF1234567890ABCDEF1234567890"
                  }
              }
          }, comment: "AMF sends a NAS Authentication Request to initiate authentication (includes RAND and AUTN). \n- **nasPdu** [Mandatory]: NAS *Authentication Request* message sent to the UE (encapsulated over NGAP).\n  - **messageType** [Mandatory]: *Authentication Request*.\n  - **rand** [Mandatory]: The random challenge generated for 5G-AKA (here shown as a 128-bit value) that the UE must use to compute its response.\n  - **autn** [Mandatory]: The authentication token corresponding to that RAND, which allows the UE to verify the network’s authenticity and derive the correct response."
          },
          {from: "gNB", to: "UE", label: "18  DLInformationTransfer (AuthenticationRequest)", info: {
              header: {msg: "DLInformationTransfer", protocol: "RRC"},
              payload: {
                  "dedicatedNAS_Message [Optional]": {
                      messageType: "AuthenticationRequest",
                      rand: "0x1234567890ABCDEF1234567890ABCDEF",
                      autn: "0xABCDEF1234567890ABCDEF1234567890"
                  }
              }
          }, comment: "gNB delivers the Authentication Request (RAND, AUTN challenge) to the UE. \n- **dedicatedNAS_Message** [Optional]: The NAS Authentication Request forwarded to the UE over RRC.\n  - **messageType** [Mandatory]: *Authentication Request*.\n  - **rand** [Mandatory]: Random challenge from the core network for AKA (same value as provided by AMF).\n  - **autn** [Mandatory]: Authentication token for the challenge (as provided by AMF)."
          },
          {from: "UE", to: "gNB", label: "19  ULInformationTransfer (AuthenticationResponse)", info: {
              header: {msg: "ULInformationTransfer", protocol: "RRC"},
              payload: {
                  "dedicatedNAS_Message [Optional]": {
                      messageType: "AuthenticationResponse",
                      resStar: "0xXXXXXXXXXXXXXXXX"
                  }
              }
          }, comment: "UE calculates the authentication response and sends an Authentication Response (containing RES*). \n- **dedicatedNAS_Message** [Optional]: The NAS *Authentication Response* generated by the UE, sent over RRC.\n  - **messageType** [Mandatory]: *Authentication Response*.\n  - **resStar** [Mandatory]: The UE’s computed response (RES*) to the RAND challenge, in its truncated/hash form as expected by the network."
          },
          {from: "gNB", to: "AMF", label: "20  UplinkNASTransport (AuthenticationResponse)", info: {
              header: {msg: "UplinkNASTransport", protocol: "NGAP"},
              payload: {
                  "nasPdu [Mandatory]": {messageType: "AuthenticationResponse", resStar: "0xXXXXXXXXXXXXXXXX"}
              }
          }, comment: "gNB forwards the UE's Authentication Response (RES*) to the AMF. \n- **nasPdu** [Mandatory]: Contains the NAS *Authentication Response* from the UE.\n  - **messageType** [Mandatory]: *Authentication Response*.\n  - **resStar** [Mandatory]: The UE’s authentication response (RES*), which the AMF/AUSF will compare with the expected XRES* to verify authentication."
          },
          {from: "AMF", to: "AUSF", label: "21  Nausf_UEAuthentication_Confirm Request", info: {
              http: {method: "PUT", uri: "/nausf-auth/v1/ue-authentications/{authId}"},
              body: {resStar: "RES*"}
          }, comment: "AMF provides the UE's authentication response (RES*) to the AUSF for verification. \n- **resStar** [Mandatory]: The UE’s computed RES* (response) for the authentication challenge, delivered to the AUSF so it can confirm whether it matches the expected value (XRES*)."
          },
          {from: "AUSF", to: "AMF", label: "22  Nausf_UEAuthentication_Confirm Response", info: {
              status: 200,
              body: {authResult: "SUCCESS"}
          }, comment: "AUSF confirms the authentication result to the AMF (successful or failure). \n- **authResult** [Mandatory]: Indicates the outcome of the authentication verification. “SUCCESS” means the RES* provided by the UE matched the expected value (XRES*), i.e. the UE is authenticated."
          },
          {from: "AMF", to: "gNB", label: "23  DownlinkNASTransport (SecurityModeCommand)", info: {
              header: {msg: "DownlinkNASTransport", protocol: "NGAP"},
              payload: {
                  "nasPdu [Mandatory]": {
                      messageType: "SecurityModeCommand",
                      selectedNAS_Algorithms: {ciphering: "NEA0", integrity: "NIA1"},
                      imeisvRequest: true
                  }
              }
          }, comment: "AMF initiates NAS security mode setup, selecting NAS ciphering/integrity algorithms and requesting the UE's IMEISV. \n- **nasPdu** [Mandatory]: NAS *Security Mode Command* message sent to establish NAS security.\n  - **messageType** [Mandatory]: *Security Mode Command* (NAS).\n  - **selectedNAS_Algorithms** [Mandatory]: The NAS protection algorithms chosen by the AMF for this UE. Here it specifies ciphering algorithm **NEA0** and integrity algorithm **NIA1** (NEA0 indicates no NAS encryption in this example, and NIA1 is an integrity algorithm).\n  - **imeisvRequest** [Optional]: A flag indicating whether the UE’s IMEISV (device identity) is requested by the network. `true` means the AMF is instructing the UE to provide its IMEISV as part of security mode completion."
          },
          {from: "gNB", to: "UE", label: "24  DLInformationTransfer (SecurityModeCommand)", info: {
              header: {msg: "DLInformationTransfer", protocol: "RRC"},
              payload: {
                  "dedicatedNAS_Message [Optional]": {
                      messageType: "SecurityModeCommand",
                      selectedNAS_Algorithms: {ciphering: "NEA0", integrity: "NIA1"},
                      imeisvRequest: true
                  }
              }
          }, comment: "gNB delivers the NAS Security Mode Command to the UE. \n- **dedicatedNAS_Message** [Optional]: The NAS *Security Mode Command* transmitted via RRC.\n  - **messageType** [Mandatory]: *Security Mode Command*.\n  - **selectedNAS_Algorithms** [Mandatory]: Indicates the NAS encryption and integrity algorithms that the AMF has selected for use (ciphering: NEA0, integrity protection: NIA1 as chosen by the AMF).\n  - **imeisvRequest** [Optional]: The UE’s IMEISV (device identity) is requested by the network (since the AMF set the flag, the UE must send its IMEISV in the Security Mode Complete)."
          },
          {from: "UE", to: "gNB", label: "25  ULInformationTransfer (SecurityModeComplete)", info: {
              header: {msg: "ULInformationTransfer", protocol: "RRC"},
              payload: {
                  "dedicatedNAS_Message [Optional]": {
                      messageType: "SecurityModeComplete",
                      imeisv: "012345678901234"
                  }
              }
          }, comment: "UE confirms the NAS security mode setup (Security Mode Complete, including the IMEISV). \n- **dedicatedNAS_Message** [Optional]: NAS *Security Mode Complete* message, indicating the UE has applied the NAS security settings.\n  - **messageType** [Mandatory]: *Security Mode Complete*.\n  - **imeisv** [Optional]: The UE’s International Mobile Equipment Identity (IMEI) with software version, provided because the network requested it (this field is present since **imeisvRequest** was true)."
          },
          {from: "gNB", to: "AMF", label: "26  UplinkNASTransport (SecurityModeComplete)", info: {
              header: {msg: "UplinkNASTransport", protocol: "NGAP"},
              payload: {
                  "nasPdu [Mandatory]": {messageType: "SecurityModeComplete", imeisv: "012345678901234"}
              }
          }, comment: "gNB forwards the Security Mode Complete (with IMEISV) to the AMF. \n- **nasPdu** [Mandatory]: Contains the NAS *Security Mode Complete* message.\n  - **messageType** [Mandatory]: *Security Mode Complete*.\n  - **imeisv** [Optional]: The IMEISV of the UE, included because the network requested the device identity (this value confirms the UE’s device identity to the network)."
          },
          {from: "AMF", to: "EIR", label: "27  N5g-eir_EquipmentIdentityCheck Request", info: {
              http: {method: "POST", uri: "/5g-eir/v1/equipment-status"},
              body: {pei: "IMEI:012345678901234", supi: "imsi-001010000000001"}
          }, comment: "AMF checks the UE's device ID (PEI/IMEI) with the EIR to see if it is blacklisted. \n- **pei** [Mandatory]: The Permanent Equipment Identifier of the UE (here given as an IMEI with SV). This is the device’s identity that the AMF wants to verify.\n- **supi** [Optional]: The subscriber’s identity (IMSI) provided alongside the request (the EIR primarily checks the equipment identity; the SUPI may be included for logging or additional policies)."
          },
          {from: "EIR", to: "AMF", label: "28  N5g-eir_EquipmentIdentityCheck Response", info: {
              status: 200,
              body: {status: "whitelist"}
          }, comment: "The EIR returns the equipment check result (e.g., indicating the PEI is not blacklisted). \n- **status** [Mandatory]: The result of the equipment identity check. “whitelist” indicates the device is recognized as allowed (not blacklisted):contentReference[oaicite:24]{index=24}."
          },
          {from: "AMF", to: "UDM", label: "29  Nudm_UEContextManagement_Registration Request", info: {
              http: {method: "PUT", uri: "/nudm-uecm/v1/{ueId}/registrations/amf-3gpp-access"},
              body: {
                  amfInstanceId: "AMF1",
                  guami: {plmnId: "00101", amfId: "abcdef"},
                  deregCallbackUri: "https://amf.example.com/namf-comm/v1/{ueId}/dereg-notify"
              }
          }, comment: "AMF registers the UE's context in the UDM (AMF information, access type, etc.). \n- **amfInstanceId** [Mandatory]: The unique identifier of the AMF instance (here “AMF1”) now serving the UE:contentReference[oaicite:25]{index=25}.\n- **guami** [Mandatory]: The Globally Unique AMF Identifier for this AMF (and the UE). It includes the serving PLMN (00101) and AMF ID (\"abcdef\"), identifying the AMF’s region/set/pointer that is serving the UE.\n- **deregCallbackUri** [Mandatory]: The callback URI that UDM should call if this UE’s registration is removed (de-registered). It points to the AMF’s API for de-registration notifications for this UE."
          },
          {from: "UDM", to: "UDR", label: "30  Nudr_DM_Update (AMF3GPPAccess)", info: {
              http: {method: "PUT", uri: "/nudr-dr/v1/subscription-data/{supi}/ue-context"},
              body: {servingAmf: "AMF1", accessType: "3GPP"}
          }, comment: "UDM updates the UDR with the UE's current serving AMF and access type. \n- **servingAmf** [Mandatory]: Identifier of the currently serving AMF for the UE (“AMF1”).\n- **accessType** [Mandatory]: The access type through which the UE is registered (\"3GPP\" indicating 5G NR access)."
          },
          {from: "UDR", to: "UDM", label: "31  Nudr_DM_Update Response", info: {
              status: 204
          }, comment: "UDR confirms storage of the registration data (HTTP 204 No Content). *(No content in the body indicates the update was successful.)*"
          },
          {from: "UDM", to: "AMF", label: "32  Nudm_UEContextManagement_Registration Response", info: {
              status: 204
          }, comment: "UDM confirms the UE context registration (success, no content)."
          },
          {from: "AMF", to: "UDM", label: "33  Nudm_SubscriberDataManagement_Get Request", info: {
              http: {method: "GET", uri: "/nudm-sdm/v1/{supi}/subscription-data?dataset=AMData,SMFSelectData"}
          }, comment: "AMF retrieves the UE's subscription data from UDM (e.g., subscribed S-NSSAIs and default DNN). \n- **dataset**: Specifies which subscription data to fetch. Here `AMData,SMFSelectData` indicates the AMF is requesting Access & Mobility subscription data (Allowed NSSAI, etc.) and SMF Selection data (default slice/DNN information)."
          },
          {from: "UDM", to: "UDR", label: "34  Nudr_DM_Query (SubscriptionData)", info: {
              http: {method: "GET", uri: "/nudr-dr/v1/subscription-data/{supi}/subscription-information"}
          }, comment: "UDM queries the UDR for the UE's subscription profile (allowed slices, default services, etc.)."
          },
          {from: "UDR", to: "UDM", label: "35  Nudr_DM_Query Response", info: {
              status: 200,
              body: {
                  amData: {allowedNSSAI: [{sst: 1, sd: "010203"}]},
                  smfSelData: {defaultSingleNssai: {sst: 1, sd: "010203"}, defaultDnn: "internet"}
              }
          }, comment: "UDR returns the subscription data (e.g., allowed NSSAI and default DNN). \n- **amData** [Optional]: Access and Mobility subscription data for the UE.\n  - **allowedNSSAI** [Optional]: The list of S-NSSAIs (slices) the UE is allowed to use in this PLMN. Here it includes SST 1, SD 010203 (the same slice requested by the UE) as an allowed slice.\n- **smfSelData** [Optional]: Session Management subscription data (used for SMF selection).\n  - **defaultSingleNssai** [Optional]: The default S-NSSAI for the UE’s default PDU session in this network (SST 1, SD 010203 in this case).\n  - **defaultDnn** [Optional]: The default Data Network Name (APN) for the UE – here `internet` – which is the default PDN the UE should use if it doesn’t specify one."
          },
          {from: "UDM", to: "AMF", label: "36  Nudm_SubscriberDataManagement_Get Response", info: {
              status: 200,
              body: {
                  allowedNSSAI: [{sst: 1, sd: "010203"}],
                  defaultDNN: "internet",
                  smsSubscribed: true,
                  smsfId: null
              }
          }, comment: "UDM responds with the UE's subscription data (Allowed S-NSSAI, default DNN, etc.). \n- **allowedNSSAI** [Optional]: The Allowed NSSAI for the UE – i.e., the slices the UE is permitted to use (here slice SST 1, SD 010203). This reflects the subscription’s allowed slice list.\n- **defaultDNN** [Optional]: The default Data Network Name (e.g., “internet”) that the UE should use for its default PDU session on the allowed slice.\n- **smsSubscribed** [Optional]: Indicates whether the UE’s subscription includes SMS-over-NAS service. `true` means the subscriber is allowed to use SMS in 5G NAS.\n- **smsfId** [Optional]: Identifies the SMSF currently handling the UE (if any). `null` here means no SMSF was assigned yet (no previous SMS context stored)."
          },
          {from: "AMF", to: "UDM", label: "37  Nudm_SubscriberDataManagement_Subscribe Request", info: {
              http: {method: "POST", uri: "/nudm-sdm/v1/{supi}/subscription-data/subscription"},
              body: {dataset: "AMData,SMFSelectData"}
          }, comment: "AMF subscribes with UDM to be notified if the subscription data changes. \n- **dataset**: The set of subscription data for which the AMF wants change notifications. Here the AMF subscribes to updates for AMData and SMFSelectData (so it will be alerted if the allowed NSSAI, default DNN, etc., change for this UE)."
          },
          {from: "UDM", to: "UDR", label: "38  Nudr_DM_Subscribe (SubscriptionData)", info: {
              http: {method: "POST", uri: "/nudr-dr/v1/subscription-data/{supi}/subscription-data-subscribe"}
          }, comment: "UDM subscribes to UDR for changes in the UE's subscription data. *(This allows UDM to get notifications from UDR, and in turn inform AMF.)*"
          },
          {from: "UDR", to: "UDM", label: "39  Nudr_DM_Subscribe Response", info: {
              status: 204
          }, comment: "UDR confirms the subscription to data change notifications (204 No Content)."
          },
          {from: "UDM", to: "AMF", label: "40  Nudm_SubscriberDataManagement_Subscribe Response", info: {
              status: 204
          }, comment: "UDM confirms the AMF's data subscription request (HTTP 204 No Content)."
          },
          {from: "AMF", to: "NRF", label: "41  Nnrf_NFDiscovery (SMSF)", info: {
              http: {method: "GET", uri: "/nnrf-nfm/v1/nf-instances?targetNfType=SMSF&requesterNfType=AMF"}
          }, comment: "AMF discovers an appropriate SMSF (for SMS over NAS service) via NRF. \n- **targetNfType**: SMSF – the AMF is querying for SMSF instances.\n- **requesterNfType**: AMF – identifies the query originator’s type."
          },
          {from: "NRF", to: "AMF", label: "42  Nnrf_NFDiscovery Response", info: {
              status: 200,
              body: {
                  nfInstances: [{
                      nfType: "SMSF",
                      nfInstanceId: "smsf1",
                      endpoint: "https://smsf.example.com/nsmsf-sm/v1"
                  }]
              }
          }, comment: "NRF returns the available SMSF's endpoint to the AMF. \n- **nfInstances**: Contains the profile(s) of discovered SMSF(s). Here one SMSF is found:\n  - **nfType**: SMSF.\n  - **nfInstanceId**: Identifier of the SMSF instance (smsf1).\n  - **endpoint**: Base URL for the SMSF’s service (SMS over NAS management API)."
          },
          {from: "AMF", to: "SMSF", label: "43  Nsmsf_SMService_Activate Request", info: {
              http: {method: "POST", uri: "/nsmsf-sm/v1/{ueId}/registrations"},
              body: {
                  supi: "imsi-001010000000001",
                  pei: "IMEI:012345678901234",
                  servingAccessType: "3GPP",
                  amfInstanceId: "AMF1",
                  amfInstanceAddress: "amf.example.com"
              }
          }, comment: "AMF informs the SMSF that the UE is now registered and requests to activate SMS over NAS service for the UE. \n- **supi** [Mandatory]: The subscriber’s identity (IMSI) for which SMS service is being activated.\n- **pei** [Optional]: The UE’s device identifier (IMEI) provided to SMSF (e.g., for device-specific routing or logging). \n- **servingAccessType** [Mandatory]: Indicates the access type over which the UE is registered (\"3GPP\" for NR access).\n- **amfInstanceId** [Mandatory]: The AMF instance ID (“AMF1”) that is serving the UE (so SMSF knows which AMF is handling this UE).\n- **amfInstanceAddress** [Optional]: The network address or hostname of that AMF instance (could be used by SMSF to contact the AMF if needed)."
          },
          {from: "SMSF", to: "NRF", label: "44  Nnrf_NFDiscovery (UDM)", info: {
              http: {method: "GET", uri: "/nnrf-nfm/v1/nf-instances?targetNfType=UDM&requesterNfType=SMSF"}
          }, comment: "SMSF discovers the UDM (to which the UE's data belongs) via NRF. *(It looks up the UDM serving the UE’s Home PLMN or subscription data.)*"
          },
          {from: "SMSF", to: "UDM", label: "45  Nudm_UEContextManagement_Registration Request (SMSF)", info: {
              http: {method: "PUT", uri: "/nudm-uecm/v1/{ueId}/registrations/smsf-3gpp-access"},
              body: {smsfInstanceId: "SMSF1", smsfAddress: "smsf.example.com"}
          }, comment: "SMSF registers itself as the UE's SMS service agent in the UDM (for 3GPP access). \n- **smsfInstanceId** [Mandatory]: Identifier of the SMSF instance (\"SMSF1\") now handling the UE’s SMS over NAS.\n- **smsfAddress** [Mandatory]: Network address of the SMSF instance (could be a domain or IP, here “smsf.example.com”) that UDM can use for any callbacks/notifications."
          },
          {from: "UDM", to: "UDR", label: "46  Nudr_DM_Update (SMSFContext)", info: {
              http: {method: "PUT", uri: "/nudr-dr/v1/subscription-data/{supi}/ue-context/smsf"},
              body: {smsfId: "SMSF1", smsfAddress: "smsf.example.com", accessType: "3GPP"}
          }, comment: "UDM updates UDR with the SMSF information for the UE (for 3GPP access SMS). \n- **smsfId** [Mandatory]: The identifier of the serving SMSF for this UE (\"SMSF1\").\n- **smsfAddress** [Optional]: The address/contact of that SMSF (e.g., FQDN or IP). Provided for completeness of the context.\n- **accessType** [Mandatory]: The access type the SMSF is serving (3GPP access in this case, meaning SMS over NR)."
          },
          {from: "UDR", to: "UDM", label: "47  Nudr_DM_Update Response", info: {
              status: 204
          }, comment: "UDR confirms storing the SMSF context (204 No Content)."
          },
          {from: "UDM", to: "SMSF", label: "48  Nudm_UEContextManagement_Registration Response", info: {
              status: 204
          }, comment: "UDM confirms the SMSF registration for the UE (success, no content)."
          },
          {from: "SMSF", to: "UDM", label: "49  Nudm_SubscriberDataManagement_Get Request (SMS)", info: {
              http: {method: "GET", uri: "/nudm-sdm/v1/{supi}/subscription-data?dataset=SMSData"}
          }, comment: "SMSF retrieves the UE's SMS subscription data (e.g., whether SMS over NAS is allowed, SMSC address) from UDM. \n- **dataset**: *SMSData*, indicating the SMSF is requesting SMS-related subscription info (such as SMS over NAS permission and the MSISDN/SMSC details)."
          },
          {from: "UDM", to: "UDR", label: "50  Nudr_DM_Query (SMS Subscription Data)", info: {
              http: {method: "GET", uri: "/nudr-dr/v1/subscription-data/{supi}/sms-data"}
          }, comment: "UDM queries the UDR for any SMS-related subscription data. *(This will fetch information like whether the subscriber has SMS service and associated numbers.)*"
          },
          {from: "UDR", to: "UDM", label: "51  Nudr_DM_Query Response", info: {
              status: 200,
              body: {smsAllowed: true, msisdn: "1234567890"}
          }, comment: "UDR returns the SMS subscription information (e.g., SMS service allowed, MSISDN). \n- **smsAllowed** [Mandatory]: Indicates if the subscriber has SMS-over-NAS service permitted (`true` meaning the UE is allowed to use NAS for SMS).\n- **msisdn** [Optional]: The MSISDN (phone number) associated with the subscription, if applicable (here a sample MSISDN)."
          },
          {from: "UDM", to: "SMSF", label: "52  Nudm_SubscriberDataManagement_Get Response (SMS)", info: {
              status: 200,
              body: {smsAllowed: true, smsfStored: false}
          }, comment: "UDM provides the SMS subscription data to the SMSF. \n- **smsAllowed** [Mandatory]: Indicates the UE is allowed to use SMS over NAS (`true`, as subscribed).\n- **smsfStored** [Optional]: Indicates whether an SMSF was already stored for this UE’s 3GPP access. `false` means this is the first time (no prior SMSF context existed)."
          },
          {from: "SMSF", to: "AMF", label: "53  Nsmsf_SMService_Activate Response", info: {
              status: 201,
              body: {result: "Activated"}
          }, comment: "SMSF confirms activation of SMS over NAS service for the UE (e.g., HTTP 201 Created). \n- **result** [Mandatory]: The outcome of the SMS activation. “Activated” indicates the UE’s SMS-over-NAS service is successfully activated on the SMSF."
          },
          {from: "AMF", to: "NSSF", label: "54  Nnssf_NSSelection_Get Request", info: {
              http: {method: "GET", uri: "/nnssf-nsselection/v1/network-slice-information?homeSnssai={sst:1,sd:'010203'}&tai=001-01-000A"}
          }, comment: "AMF requests allowed slice(s) and configuration from the NSSF for the UE's subscribed S-NSSAI. \n- **homeSnssai** [Optional]: The S-NSSAI from the UE’s home subscription (SST 1, SD 010203) that the UE is attempting to use. This is provided to NSSF so it can consider roaming slice mappings if needed.\n- **tai** [Mandatory]: The Tracking Area Identity (001-01-000A) indicating the UE’s location. NSSF uses the TAI to determine which slices are available/allowed in that area."
          },
          {from: "NSSF", to: "AMF", label: "55  Nnssf_NSSelection_Get Response", info: {
              status: 200,
              body: {allowedNssai: [{sst: 1, sd: "010203"}], targetAmfSet: "AMF_SET_1"}
          }, comment: "NSSF returns the Allowed NSSAI for the UE (and possibly target AMF set or candidate AMFs). \n- **allowedNssai** [Mandatory]: The list of S-NSSAIs that the UE is allowed to use in the current serving area. In this case, it returns SST 1, SD 010203 (the slice is allowed as is).\n- **targetAmfSet** [Optional]: A suggested AMF Set ID (or target AMF) for serving the UE’s slice. Here “AMF_SET_1” indicates that if needed, the UE could be served by AMFs in set 1 (often used if the slice is only handled by a specific AMF set)."
          },
          {from: "AMF", to: "PCF", label: "56  Npcf_AMPolicyControl_Create Request", info: {
              http: {method: "POST", uri: "/npcf-am-policy-control/v1/policies"},
              body: {supi: "imsi-001010000000001", accessType: "3GPP", allowedNssai: [{sst: 1, sd: "010203"}]}
          }, comment: "AMF establishes an AM Policy association with the PCF for the UE. \n- **supi** [Mandatory]: The subscriber’s identity for which an access and mobility policy is being created.\n- **accessType** [Mandatory]: The access type (“3GPP” for cellular) that the UE is using.\n- **allowedNssai** [Optional]: The Allowed NSSAI that the UE has in the serving network. The AMF provides the list of allowed slice(s) (here SST 1/SD 010203) so that PCF can take slice-based policy decisions."
          },
          {from: "PCF", to: "AMF", label: "57  Npcf_AMPolicyControl_Create Response", info: {
              status: 201,
              body: {
                  policyAssociationId: "PA-001",
                  amPolicy: {
                      policyControlReqTriggers: ["LOC_CH"],
                      policyConstraints: {}
                  }
              }
          }, comment: "PCF confirms the creation of the AM Policy Association and returns a Policy Association ID. \n- **policyAssociationId** [Mandatory]: An identifier for the policy association that has been created (e.g., “PA-001”). The AMF will use this ID for subsequent policy updates.\n- **amPolicy** [Optional]: The details of the policy rules and triggers.\n  - **policyControlReqTriggers** [Optional]: A list of events that should trigger the AMF to report to PCF. Here it includes “LOC_CH” (location change), meaning PCF wants to be informed if the UE’s location changes:contentReference[oaicite:26]{index=26}.\n  - **policyConstraints** [Optional]: Any specific constraints on the policy. (Empty in this case, indicating default or no special constraints.)"
          },
          {from: "AMF", to: "NRF", label: "58  Nnrf_NFDiscovery (SMF)", info: {
              http: {method: "GET", uri: "/nnrf-nfm/v1/nf-instances?targetNfType=SMF&requesterNfType=AMF&snssai=010203&dnn=internet"}
          }, comment: "AMF discovers a suitable SMF for the default PDU session (matching the allowed S-NSSAI and DNN) via NRF. \n- **targetNfType**: SMF (looking for Session Management Function instances).\n- **requesterNfType**: AMF (identifies the querying NF’s type).\n- **snssai** [Optional]: S-NSSAI filter (010203 corresponds to SST=1, SD=010203) to find an SMF serving that slice.\n- **dnn** [Optional]: DNN filter (“internet”) to find an SMF that serves the default data network."
          },
          {from: "NRF", to: "AMF", label: "59  Nnrf_NFDiscovery Response", info: {
              status: 200,
              body: {
                  nfInstances: [{
                      nfType: "SMF",
                      nfInstanceId: "smf1",
                      endpoint: "https://smf.example.com/nsmf-pdusession/v1"
                  }]
              }
          }, comment: "NRF returns the available SMF's endpoint to the AMF. \n- **nfInstances**: List of SMF instance(s) that match the query (slice=DNN). Here one SMF instance is returned with:\n  - **nfType**: SMF.\n  - **nfInstanceId**: “smf1”.\n  - **endpoint**: Base URL for SMF’s PDU Session Management service."
          },
          {from: "AMF", to: "SMF", label: "60  Nsmf_PDUSession_CreateSMContext Request", info: {
              http: {method: "POST", uri: "/nsmf-pdusession/v1/sm-contexts"},
              body: {
                  supi: "imsi-001010000000001",
                  pduSessionId: 10,
                  sNssai: {sst: 1, sd: "010203"},
                  dnn: "internet",
                  requestType: "InitialRequest"
              }
          }, comment: "AMF requests the SMF to establish a PDU Session for the UE (providing SUPI, DNN, S-NSSAI, etc.). \n- **supi** [Mandatory]: The subscriber’s identity (IMSI) for which a PDU session is being established.\n- **pduSessionId** [Mandatory]: The PDU session identifier (10) assigned to this session (identifies the session from UE and network side).\n- **sNssai** [Mandatory]: The single network slice identifier that this PDU session will use (SST=1, SD=010203) – corresponds to the allowed/default slice for the UE.\n- **dnn** [Mandatory]: The Data Network Name for this session (here “internet”, the APN for default internet service).\n- **requestType** [Mandatory]: Indicates the type of request – *InitialRequest* denotes that this is a new session establishment (as opposed to a handover or modification)."
          },
          {from: "SMF", to: "UDM", label: "61  Nudm_SubscriberDataManagement_Get Request (SMF)", info: {
              http: {method: "GET", uri: "/nudm-sdm/v1/{supi}/subscription-data?dataset=SMData"}
          }, comment: "SMF retrieves the session management subscription data from the UDM (allowed PDU session types, SSC modes, APN/DNN info, etc.). \n- **dataset**: *SMData*, indicating the SMF is requesting Session Management related subscription data (such as allowed session types, allowed SSC modes, subscribed DNNs for the UE)."
          },
          {from: "UDM", to: "UDR", label: "62  Nudr_DM_Query (SessionManagementData)", info: {
              http: {method: "GET", uri: "/nudr-dr/v1/subscription-data/{supi}/sm-data"}
          }, comment: "UDM queries UDR for session management-related subscription data."
          },
          {from: "UDR", to: "UDM", label: "63  Nudr_DM_Query Response", info: {
              status: 200,
              body: {
                  allowedPDUSessionTypes: ["IPv4", "IPv6"],
                  allowedSSCModes: [1, 2],
                  subscribedDnn: "internet"
              }
          }, comment: "UDR returns the session management subscription info (e.g., allowed PDU session types, allowed SSC modes, subscribed DNN). \n- **allowedPDUSessionTypes** [Optional]: The types of PDU sessions the UE is allowed to establish (e.g., [\"IPv4\", \"IPv6\"] indicating the UE can have IPv4 or IPv6 PDUs, or IPv4v6 if both are listed).\n- **allowedSSCModes** [Optional]: The allowed SSC (Session Continuity) modes for the UE (e.g., mode 1 and 2 allowed). These modes define how the network handles session continuity under various conditions.\n- **subscribedDnn** [Optional]: The subscribed default Data Network Name for the UE (here “internet”), confirming which APN/DNN the UE is entitled to use."
          },
          {from: "UDM", to: "SMF", label: "64  Nudm_SubscriberDataManagement_Get Response (SMF)", info: {
              status: 200,
              body: {allowedPDUSessionTypes: ["IPv4", "IPv6"], allowedSSCModes: [1, 2]}
          }, comment: "UDM responds with the requested session management subscription data. \n- **allowedPDUSessionTypes** [Optional]: Allowed PDU session address types for the UE’s subscription (IPv4 and IPv6 are permitted).\n- **allowedSSCModes** [Optional]: Allowed SSC modes for the UE’s sessions (1 and 2 in this case, meaning the subscription allows those session continuity modes)."
          },
          {from: "SMF", to: "PCF", label: "65  Npcf_SMPolicyControl_Create Request", info: {
              http: {method: "POST", uri: "/npcf-smpolicycontrol/v1/sm-policies"},
              body: {
                  supi: "imsi-001010000000001",
                  pduSessionId: 10,
                  notifUri: "https://smf.example.com/nsmf-pdusession/v1/sm-policies/10/notify",
                  dnn: "internet",
                  sNssai: {sst: 1, sd: "010203"}
              }
          }, comment: "SMF establishes an SM Policy Association with PCF to obtain policy rules for the PDU Session. \n- **supi** [Mandatory]: The subscriber’s ID for whom the session is established (used by PCF to fetch subscriber-specific policy info).\n- **pduSessionId** [Mandatory]: The identifier of the PDU session (10) for which policies are being requested.\n- **notifUri** [Mandatory]: A callback URI that the SMF provides to PCF, so the PCF can notify the SMF of any policy updates for this session.\n- **dnn** [Mandatory]: The Data Network Name (\"internet\") for this session, which PCF may use to select applicable policies (e.g., QoS rules for the internet APN).\n- **sNssai** [Mandatory]: The slice identifier (SST 1, SD 010203) for this PDU session, allowing PCF to apply slice-specific policy if needed."
          },
          {from: "PCF", to: "SMF", label: "66  Npcf_SMPolicyControl_Create Response", info: {
              status: 201,
              body: {
                  smPolicyId: "SM-Policy-001",
                  pccRules: [],
                  policyCtrlReqTriggers: ["PLMN_CH"]
              }
          }, comment: "PCF returns a successful SM Policy Association establishment with a policy ID and default PCC rules. \n- **smPolicyId** [Mandatory]: The identifier for the created SM Policy association (e.g., “SM-Policy-001”). The SMF will reference this in any further interactions with PCF about this session.\n- **pccRules** [Optional]: The initial set of PCC (Policy and Charging Control) rules for this session. (Empty array here indicates no specific PCC rules are pre-provisioned for the session by default.)\n- **policyCtrlReqTriggers** [Optional]: Events that should trigger the SMF to report back to PCF or request an updated policy. Here [\"PLMN_CH\"] indicates that if the UE’s PLMN or roaming status changes, it should trigger a policy re-evaluation (e.g., if the UE moves to another PLMN)– an event PCF is interested in."
          },
          {from: "SMF", to: "UPF", label: "67  PFCP Session Establishment Request", info: {
              header: {msg: "PFCP Session Establishment Request", protocol: "PFCP"},
              payload: {seid: "0x1001", pdrList: [], farList: []}
          }, comment: "SMF interacts with the UPF to establish the user plane for the PDU Session (creating an N4 session context). \n- **seid** [Mandatory]: The Session Endpoint Identifier proposed for this PFCP session on the UPF (0x1001). This identifies the PFCP session between SMF and UPF.\n- **pdrList** [Mandatory]: The list of PDRs (Packet Detection Rules) that define how to handle uplink/downlink packets for this session. (Empty here for brevity – in practice, SMF would include at least one PDR.)\n- **farList** [Mandatory]: The list of FARs (Forwarding Action Rules) corresponding to the PDRs, specifying actions like forward, drop, or duplicate. (Empty in this simplified view.)"
          },
          {from: "UPF", to: "SMF", label: "68  PFCP Session Establishment Response", info: {
              header: {msg: "PFCP Session Establishment Response", protocol: "PFCP"},
              payload: {cause: "Request accepted", ulTunnelInfo: {teid: "0x2001", upfIp: "198.51.100.1"}}
          }, comment: "UPF confirms the PFCP session establishment and provides tunnel info (TEIDs, addresses) to the SMF. \n- **cause** [Mandatory]: Indicates the result of the PFCP session setup. “Request accepted” confirms the UPF has successfully established the session.\n- **ulTunnelInfo** [Mandatory]: Information for the uplink GTP-U tunnel that has been allocated on the UPF for this PDU session.\n  - **teid** [Mandatory]: The Tunnel Endpoint Identifier that the UPF expects the gNB to use for uplink traffic (0x2001 in this case).\n  - **upfIp** [Mandatory]: The IP address of the UPF’s GTP-U endpoint (198.51.100.1) where the gNB should send uplink user-plane packets."
          },
          {from: "SMF", to: "AMF", label: "69  Namf_N1N2MessageTransfer (PDU Accept)", info: {
              http: {method: "POST", uri: "/namf-comm/v1/ue-contexts/{ueId}/n1-n2-messages"},
              body: {
                  n1Message: {nasPdu: "PDU Session Establishment Accept"},
                  n2Info: {pduSessionId: 10, upfTunnelInfo: {teid: "0x2001", upfIp: "198.51.100.1"}}
              }
          }, comment: "SMF notifies the AMF that the PDU Session was established, providing the NAS PDU Session Establishment Accept and related N2 (user plane) information. \n- **n1Message** [Mandatory]: Contains the N1 NAS message that needs to be delivered to the UE. Here it includes the NAS *PDU Session Establishment Accept* (signaling successful session setup to the UE).\n- **n2Info** [Optional]: Contains N2 information for RAN to establish user-plane. It includes:\n  - **pduSessionId** [Mandatory]: The PDU Session ID (10) of the session just established.\n  - **upfTunnelInfo** [Mandatory]: The tunnel endpoint info that the UPF has allocated for this session (to be used by the gNB for downlink).\n    - **teid** [Mandatory]: GTP-U TEID on the UPF for downlink traffic (0x2001, as provided by UPF).\n    - **upfIp** [Mandatory]: UPF’s IP address for the GTP-U tunnel (198.51.100.1)."
          },
          {from: "AMF", to: "gNB", label: "70  InitialContextSetupRequest", info: {
              header: {msg: "InitialContextSetupRequest", protocol: "NGAP"},
              payload: {
                  "nasPdu": {
                      "messageType": "RegistrationAccept",
                      "guti": {plmnId: "001/01", amfRegionId: 1, amfSetId: 1, amfPointer: 2, tmsi: "0x11111111"},
                      "taiList": [{plmnId: "001/01", tac: "000A"}],
                      "allowedNSSAI": [{sst: 1, sd: "010203"}],
                      "smsAllowed": true
                  },
                  "pduSessionResourceSetupList": [{
                      pduSessionId: 10,
                      upfTunnelInfo: {teid: "0x2001", upfIp: "198.51.100.1"}
                  }]
              }
          }, comment: "AMF establishes the UE's context at the gNB, sending the Registration Accept NAS message (with new 5G-GUTI, allowed NSSAI, TAI list, etc.) and including the default PDU Session setup information (UPF tunnel endpoint). \n- **nasPdu** (Registration Accept): The NAS Registration Accept message for the UE’s attach.\n  - **messageType** [Mandatory]: *Registration Accept* – indicating the NAS procedure acceptance for registration.\n  - **guti** [Optional]: The new 5G-GUTI assigned to the UE. It includes the PLMN (001/01) and the AMF’s region/Set/pointer and TMSI components. The UE will use this GUTI for future identifications in this network.\n  - **taiList** [Mandatory]: The list of Tracking Areas the UE is registered in. Here it contains the current TA (PLMN 001/01, TAC 000A). The UE uses this list to know in which TAs it can roam without re-registering.\n  - **allowedNSSAI** [Mandatory]: The Allowed NSSAI provided to the UE – i.e., the list of slices it can use in this registration area. Here the slice {SST=1, SD=010203} is indicated, matching the UE’s subscribed/requested slice.\n  - **smsAllowed** [Mandatory]: An indicator in the Registration Accept showing whether SMS-over-NAS is allowed for the UE. *True* means the UE is allowed to send/receive SMS via NAS in this network:contentReference[oaicite:27]{index=27}.\n- **pduSessionResourceSetupList** [Optional]: List of PDU Session resources to set up in the RAN as part of context setup.\n  - **pduSessionId** [Mandatory]: The ID of the PDU session to be set up (10, the default session just established).\n  - **upfTunnelInfo** [Mandatory]: The user-plane tunnel info for this session from the UPF:\n    - **teid** [Mandatory]: GTP-U TEID for downlink data (UPF -> gNB) allocated by the UPF (0x2001).\n    - **upfIp** [Mandatory]: The IP address of the UPF for this GTP-U tunnel (198.51.100.1). The gNB will use this info to set up the GTP-U tunnel for downlink traffic."
          },
          {from: "gNB", to: "UE", label: "71  RRCSecurityModeCommand", info: {
              header: {msg: "RRCSecurityModeCommand", protocol: "RRC"},
              payload: {
                  securityAlgorithmConfig: {ciphering: "NEA2", integrity: "NIA2"}
              }
          }, comment: "gNB activates AS security, configuring the RRC and user-plane encryption/integrity algorithms. \n- **securityAlgorithmConfig** [Mandatory]: Contains the selected Access-Stratum security algorithms for RRC and UP traffic:\n  - **ciphering** [Mandatory]: *NEA2* – the ciphering algorithm for RRC/user-plane (NEA2 is a specific 128-bit AES encryption algorithm for NR).\n  - **integrity** [Mandatory]: *NIA2* – the integrity protection algorithm for RRC signaling (NIA2 is a 128-bit AES CMAC algorithm)."
          },
          {from: "UE", to: "gNB", label: "72  RRCSecurityModeComplete", info: {
              header: {msg: "RRCSecurityModeComplete", protocol: "RRC"},
              payload: {}
          }, comment: "UE acknowledges the activation of AS security (RRC Security Mode Complete). *(No payload – this message is just a confirmation.)*"
          },
          {from: "gNB", to: "UE", label: "73  DLInformationTransfer (RegistrationAccept + PDU Session Accept)", info: {
              header: {msg: "DLInformationTransfer", protocol: "RRC"},
              payload: {
                  dedicatedNAS_Message: [
                      {
                          messageType: "RegistrationAccept",
                          guti: {plmnId: "001/01", amfRegionId: 1, amfSetId: 1, amfPointer: 2, tmsi: "0x11111111"},
                          taiList: [{plmnId: "001/01", tac: "000A"}],
                          allowedNSSAI: [{sst: 1, sd: "010203"}],
                          smsAllowed: true
                      },
                      {
                          messageType: "PDUSessionEstablishmentAccept",
                          pduSessionId: 10,
                          pduSessionType: "IPv4",
                          allocatedIPAddress: "10.0.0.10",
                          sNssai: {sst: 1, sd: "010203"},
                          dnn: "internet",
                          upfTunnelInfo: {teid: "0x2001", upfIp: "198.51.100.1"}
                      }
                  ]
              }
          }, comment: "gNB delivers the Registration Accept (with assigned GUTI, allowed NSSAI, etc.) along with the PDU Session Establishment Accept to the UE. \n- **Registration Accept** (NAS message 1):\n  - **messageType** [Mandatory]: *Registration Accept*.\n  - **guti** [Optional]: The new 5G-GUTI assigned to the UE (PLMN 001/01, AMF IDs, and TMSI) that the UE will use for future identification in this network.\n  - **taiList** [Mandatory]: List of Tracking Areas the UE is registered in (here one TA: 001/01 TAC 000A). The UE will consider itself registered in these areas.\n  - **allowedNSSAI** [Mandatory]: Allowed slice list for the UE in this area (SST=1/SD=010203) – the network’s confirmation of slices the UE can use.\n  - **smsAllowed** [Mandatory]: Indicates SMS-over-NAS is allowed for the UE in this network (set to true, matching the earlier indication).\n- **PDU Session Establishment Accept** (NAS message 2 for PDU session 10):\n  - **messageType** [Mandatory]: *PDU Session Establishment Accept* – confirms the session setup.\n  - **pduSessionId** [Mandatory]: 10, the ID of the PDU session that has been established.\n  - **pduSessionType** [Mandatory]: *IPv4* – the type of PDU session (only IPv4 address was assigned to the UE).\n  - **allocatedIPAddress** [Mandatory]: The IPv4 address allocated to the UE for this session (10.0.0.10).\n  - **sNssai** [Mandatory]: The slice identifier used for this PDU session (SST 1, SD 010203), echoing the allowed slice for this session.\n  - **dnn** [Mandatory]: The Data Network Name for this session (\"internet\").\n  - **upfTunnelInfo** [Optional]: The user-plane tunnel info (GTP-U) for this session, as provided by the SMF. It includes the UPF’s TEID and IP for downlink traffic. *(This tunnel info is delivered via NGAP to gNB; it is not part of the NAS PDU sent to the UE, but included here for completeness of the message.)*"
          },
          {from: "UE", to: "gNB", label: "74  ULInformationTransfer (RegistrationComplete)", info: {
              header: {msg: "ULInformationTransfer", protocol: "RRC"},
              payload: {dedicatedNAS_Message: {messageType: "RegistrationComplete"}}
          }, comment: "UE indicates the completion of the registration procedure (Registration Complete). \n- **dedicatedNAS_Message** [Optional]: NAS *Registration Complete* message, indicating the UE has finished the registration process and no further NAS messages are pending.\n  - **messageType** [Mandatory]: *Registration Complete*."
          },
          {from: "gNB", to: "AMF", label: "75  UplinkNASTransport (RegistrationComplete)", info: {
              header: {msg: "UplinkNASTransport", protocol: "NGAP"},
              payload: {nasPdu: {messageType: "RegistrationComplete"}}
          }, comment: "gNB forwards the Registration Complete NAS message to the AMF. *(This informs the AMF that the UE has acknowledged the Registration Accept and that the initial registration procedure is complete on the UE side.)*"
          },
          {from: "AMF", to: "gNB", label: "76  InitialContextSetupResponse", info: {
              header: {msg: "InitialContextSetupResponse", protocol: "NGAP"},
              payload: {
                  pduSessionResourceSetupResponseList: [{pduSessionId: 10, status: "success"}]
              }
          }, comment: "gNB confirms successful setup of the context and PDU Session to the AMF. \n- **pduSessionResourceSetupResponseList** [Optional]: The list of PDU session resources that were set up in the RAN and their status.\n  - **pduSessionId** [Mandatory]: 10 (the PDU session that was set up).\n  - **status** [Mandatory]: “success”, indicating the gNB successfully established radio resources for that PDU session."
          },
          {from: "gNB", to: "UE", label: "77  RRCReconfiguration", info: {
              header: {msg: "RRCReconfiguration", protocol: "RRC"},
              payload: {
                  "rrcTransactionIdentifier [Mandatory]": 1,
                  "srb_ToAddModList [Optional]": [
                      {"srb_Identity [Mandatory]": 2}
                  ],
                  "drb_ToAddModList [Optional]": [
                      {"drb_Identity [Mandatory]": 1}
                  ]
              }
          }, comment: "gNB configures the default radio bearer (DRB) for the PDU session (and sets up SRB2 for dedicated signaling) via an RRC Reconfiguration message. \n- **rrcTransactionIdentifier** [Mandatory]: Transaction ID for this RRC Reconfiguration (here 1, since it’s a new transaction distinct from the initial RRC setup sequence).\n- **srb_ToAddModList** [Optional]: List of additional Signaling Radio Bearers to add. Here it is used to set up **SRB2** (with identity 2) for dedicated NAS signaling on a separate logical channel.\n  - **srb_Identity** [Mandatory]: 2, indicating SRB2 is being established.\n- **drb_ToAddModList** [Optional]: List of Data Radio Bearers to add for user data. This configures the default **DRB** for the newly established PDU session.\n  - **drb_Identity** [Mandatory]: 1, identifying the DRB being set up (DRB1) for carrying user plane traffic for the PDU session."
          },
          {from: "UE", to: "gNB", label: "78  RRCReconfigurationComplete", info: {
              header: {msg: "RRCReconfigurationComplete", protocol: "RRC"},
              payload: {}
          }, comment: "UE confirms the radio bearer configuration (RRC reconfiguration complete). *(No payload; this acknowledges the addition of SRB2 and DRB1.)*"
          },
          {from: "AMF", to: "SMF", label: "79  Nsmf_PDUSession_UpdateSMContext Request", info: {
              http: {method: "PUT", uri: "/nsmf-pdusession/v1/sm-contexts/10"},
              body: {pduSessionId: 10, anTunnelInfo: {teid: "0x3001", gnbIp: "10.1.1.1"}}
          }, comment: "AMF provides the gNB's tunnel endpoint info (GTP-U address/TEID) to the SMF, allowing the SMF to finalize user plane setup. \n- **pduSessionId** [Mandatory]: The PDU session ID (10) being updated.\n- **anTunnelInfo** [Mandatory]: The Access Network tunnel information that the gNB has allocated for downlink data:\n  - **teid** [Mandatory]: The TEID that the gNB will use for downlink user-plane GTP-U packets (0x3001 in this case, provided by the gNB in the Initial Context Setup Response).\n  - **gnbIp** [Mandatory]: The IP address of the gNB’s GTP-U endpoint (10.1.1.1) for this session."
          },
          {from: "SMF", to: "AMF", label: "80  Nsmf_PDUSession_UpdateSMContext Response", info: {
              status: 200,
              body: {result: "OK"}
          }, comment: "SMF acknowledges the update of the PDU Session context (user plane information). *(A simple 200 OK with result indicates the SMF has integrated the gNB’s tunnel info and the user plane path is fully set up.)*"
          },
          {from: "AMF", to: "gNB", label: "81  UEContextReleaseCommand", info: {
              header: {msg: "UEContextReleaseCommand", protocol: "NGAP"},
              payload: {cause: "UE-NormalRelease"}
          }, comment: "AMF instructs the gNB to release the UE's RAN context (e.g., after successful registration, UE moving to idle). \n- **cause** [Mandatory]: The reason for the release. “UE-NormalRelease” indicates a normal release (e.g., the registration procedure is complete and the UE can be moved to idle, or requested by UE)."
          },
          {from: "gNB", to: "UE", label: "82  RRCRelease", info: {
              header: {msg: "RRCRelease", protocol: "RRC"},
              payload: {releaseCause: "normal"}
          }, comment: "gNB releases the RRC connection; UE goes idle. \n- **releaseCause** [Optional]: The reason for RRC release as given by gNB. “normal” indicates a normal release (no error). (If not provided, the UE assumes normal release by default.)"
          },
          {from: "gNB", to: "AMF", label: "83  UEContextReleaseComplete", info: {
              header: {msg: "UEContextReleaseComplete", protocol: "NGAP"},
              payload: {}
          }, comment: "gNB confirms the UE context release to the AMF; the registration procedure is fully complete. *(No payload; this message signals that the gNB has released radio resources and the UE’s NGAP context is cleared.)*"
          }
      ];


      /* ====== 页面元素 ====== */
      const headerInner=document.getElementById('header-names-inner');
      const bodyDiv=document.getElementById('diagram-body');
      const svg=document.getElementById('diagram');
      const diagramContainer=document.getElementById('diagram-container');
      const verticalDivider=document.getElementById('vertical-divider');
      const viewerWrapper=document.getElementById('viewer-wrapper');

      const rightDetail=document.getElementById('right-detail');
      const jsonViewer=document.getElementById('json-viewer');
      const commentViewer=document.getElementById('comment-viewer');
      const commentContent=document.getElementById('comment-content');
      const hDivider=document.getElementById('horizontal-divider');

      /* ====== 绘制信令图 ====== */
      const headerHeight=50;
      const margin={top:headerHeight,bottom:50,left:100,right:100};
      const xStep=200,msgSpacing=80;
      const totalHeight=margin.top+msgSpacing*(messages.length+1)+margin.bottom;
      const totalWidth=margin.left+xStep*(nodes.length-1)+margin.right;
      svg.setAttribute('width',totalWidth);
      svg.setAttribute('height',totalHeight);
      headerInner.style.width=totalWidth+'px';

      /* X 坐标 */
      const xs={};
      nodes.forEach((n,i)=>{
        const x=margin.left+i*xStep;
        xs[n]=x;
        const d=document.createElement('div');
        d.className='node-name';
        d.textContent=n;
        d.style.left=x+'px';
        headerInner.appendChild(d);
        const line=document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1',x);line.setAttribute('y1',margin.top);
        line.setAttribute('x2',x);line.setAttribute('y2',totalHeight-margin.bottom);
        line.setAttribute('stroke','#aaa');line.setAttribute('stroke-dasharray','4 2');
        svg.appendChild(line);
      });

      /* 箭头 marker */
      const defs=document.createElementNS('http://www.w3.org/2000/svg','defs');
      const marker=document.createElementNS('http://www.w3.org/2000/svg','marker');
      marker.setAttribute('id','arrow');marker.setAttribute('markerWidth','8');marker.setAttribute('markerHeight','8');
      marker.setAttribute('refX','6');marker.setAttribute('refY','3');marker.setAttribute('orient','auto');
      const path=document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d','M0,0 L0,6 L6,3 Z');path.setAttribute('fill','#000');
      marker.appendChild(path);defs.appendChild(marker);svg.appendChild(defs);

      /* 渲染消息线条和标签 */
      messages.forEach((m,i)=>{
        const y=margin.top+msgSpacing*(i+1);
        const x1=xs[m.from],x2=xs[m.to];
        const ln=document.createElementNS('http://www.w3.org/2000/svg','line');
        ln.setAttribute('x1',x1);ln.setAttribute('y1',y);
        ln.setAttribute('x2',x2);ln.setAttribute('y2',y);
        ln.setAttribute('stroke','#000');ln.setAttribute('marker-end','url(#arrow)');
        svg.appendChild(ln);
        const lbl=document.createElementNS('http://www.w3.org/2000/svg','text');
        lbl.setAttribute('x',(x1+x2)/2);lbl.setAttribute('y',y-6);
        lbl.setAttribute('text-anchor','middle');lbl.classList.add('message-label');
        lbl.textContent=m.label;
        lbl.addEventListener('click',()=>{
          renderJSON(m.info,jsonViewer);
          commentContent.innerHTML=marked.parse(m.comment);
        });
        svg.appendChild(lbl);
      });

      /* ====== JSON 渲染函数 ====== */
      function renderJSON(obj,container){
        container.innerHTML='';
        function walk(k,v,parent){
          if(v&&typeof v==='object'){
            const d=document.createElement('details');d.open=true;
            const s=document.createElement('summary');s.textContent=k;d.appendChild(s);
            for(const kk in v)walk(kk,v[kk],d);
            parent.appendChild(d);
          }else{
            const div=document.createElement('div');
            div.textContent=k+': '+v;parent.appendChild(div);
          }
        }
        for(const key in obj)walk(key,obj[key],container);
      }

      
      /* ====== 同步水平滚动，保持节点标题与竖线对齐 ===== */
      bodyDiv.addEventListener('scroll', () => {
        headerInner.style.transform = `translateX(${-bodyDiv.scrollLeft}px)`;
      });
      /* 初始化一次，避免刚加载时错位 */
      headerInner.style.transform = 'translateX(0px)';
      /* ====== 右侧面板拖拽 ===== */
      verticalDivider.addEventListener('mousedown',e=>{
        e.preventDefault();
        const startX=e.clientX,startW=viewerWrapper.offsetWidth;
        function onMove(ev){viewerWrapper.style.width=(startW-(ev.clientX-startX))+'px';}
        function stop(){document.removeEventListener('mousemove',onMove);document.removeEventListener('mouseup',stop);}
        document.addEventListener('mousemove',onMove);document.addEventListener('mouseup',stop);
      });

      function initVertical(){const h=rightDetail.clientHeight/2;jsonViewer.style.top='0';jsonViewer.style.height=h+'px';hDivider.style.top=h+'px';commentViewer.style.top=(h+5)+'px';commentViewer.style.height=(h-5)+'px';}
      initVertical();window.addEventListener('resize',initVertical);
      hDivider.addEventListener('mousedown',e=>{
        e.preventDefault();
        const startY=e.clientY,startH=jsonViewer.offsetHeight;
        function onMove(ev){
          const newH=startH+(ev.clientY-startY);
          jsonViewer.style.height=newH+'px';hDivider.style.top=newH+'px';
          commentViewer.style.top=(newH+5)+'px';commentViewer.style.height=(rightDetail.clientHeight-newH-5)+'px';
        }
        function stop(){document.removeEventListener('mousemove',onMove);document.removeEventListener('mouseup',stop);}
        document.addEventListener('mousemove',onMove);document.addEventListener('mouseup',stop);
      });

      /* ====== 缩放与平移 ===== */
      const originalW=totalWidth,originalH=totalHeight;let scale=1;
      svg.setAttribute('viewBox',`0 0 ${originalW} ${originalH}`);

      /* 拖拽平移（保持功能，不改变指针样式） */
      let dragging=false,sx=0,sy=0;
      diagramContainer.addEventListener('mousedown',e=>{
        dragging=true;sx=e.clientX;sy=e.clientY;e.preventDefault();});
      document.addEventListener('mousemove',e=>{
        if(!dragging) return;
        diagramContainer.scrollLeft-=e.clientX-sx;
        diagramContainer.scrollTop -=e.clientY-sy;
        sx=e.clientX;sy=e.clientY;
      });
      document.addEventListener('mouseup',()=>{dragging=false;});

      /* 缩放 */
      diagramContainer.addEventListener('wheel',e=>{
        if(!e.ctrlKey)return;
        e.preventDefault();
        const factor=(Math.abs(e.deltaY)<50)?(e.deltaY<0?1.05:0.95):(e.deltaY<0?1.2:0.8);
        const newScale=scale*factor;if(newScale<0.1||newScale>10)return;
        const rect=diagramContainer.getBoundingClientRect();
        const cx=e.clientX-rect.left,cy=e.clientY-rect.top;
        const contentX=(diagramContainer.scrollLeft+cx)/scale;
        const contentY=(diagramContainer.scrollTop+cy)/scale;
        scale=newScale;
        svg.setAttribute('width',originalW*scale);svg.setAttribute('height',originalH*scale);
        headerInner.style.width=(originalW*scale)+'px';
        nodes.forEach((n,i)=>{headerInner.children[i].style.left=((margin.left+i*xStep)*scale)+'px';});
        diagramContainer.scrollLeft=contentX*scale-cx;
        diagramContainer.scrollTop =contentY*scale-cy;
      },{passive:false});
    });
  </script>

  <script id="addon-script">
    document.addEventListener('DOMContentLoaded', function(){
      const labels = Array.from(document.querySelectorAll('.message-label'));
      let currentIdx = -1;
      const select = (idx, viaKey=false) => {
        if(idx < 0 || idx >= labels.length) return;
        if(currentIdx >= 0) labels[currentIdx].classList.remove('selected');
        currentIdx = idx;
        const lbl = labels[currentIdx];
        lbl.classList.add('selected');
        if(viaKey) {
          lbl.scrollIntoView({block:'center', inline:'center'});
        }
        lbl.dispatchEvent(new Event('click'));
      };
      labels.forEach((lbl, idx) => {
        lbl.addEventListener('click', () => {
          if(currentIdx >= 0) labels[currentIdx].classList.remove('selected');
          currentIdx = idx;
          lbl.classList.add('selected');
        });
      });
      document.addEventListener('keydown', (e) => {
        if(e.key === 'ArrowDown'){
          e.preventDefault();
          select(currentIdx + 1, true);
        } else if(e.key === 'ArrowUp'){
          e.preventDefault();
          select(currentIdx - 1, true);
        }
      });
    });
  </script>
</body>
</html>
